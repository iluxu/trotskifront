<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>STT Interview Panel</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'SF Mono', 'Monaco', 'Cascadia Code', 'Roboto Mono', monospace;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 50%, #16213e 100%);
            color: #e6e6e6;
            height: 100vh;
            overflow: hidden;
        }

        .header {
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            padding: 0.75rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            font-size: 1.2rem;
            font-weight: 600;
            color: #00d4ff;
            text-shadow: 0 0 10px rgba(0, 212, 255, 0.3);
        }

        .status-indicators {
            display: flex;
            gap: 1rem;
            font-size: 0.8rem;
        }

        .license-bar {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 0.6rem;
            padding: 0.6rem 1.5rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            background: rgba(0, 0, 0, 0.25);
        }

        .license-status {
            font-size: 0.85rem;
            color: #ffd93d;
            margin-right: 0.5rem;
        }

        .license-input {
            background: rgba(0, 0, 0, 0.35);
            border: 1px solid rgba(255, 255, 255, 0.15);
            color: #e6e6e6;
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            min-width: 240px;
        }

        .license-btn {
            background: #00d4ff;
            color: #0f0f23;
            border: none;
            padding: 0.45rem 0.8rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 600;
        }

        .license-btn.secondary {
            background: transparent;
            color: #e6e6e6;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .license-link {
            color: #6bcf7f;
            text-decoration: none;
            font-size: 0.85rem;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        .status-connected { background: #00ff88; }
        .status-disconnected { background: #ff6b6b; }
        .status-auto-scroll { background: #ffd93d; }
        .status-follow { background: #6bcf7f; }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .main-container {
            display: grid;
            grid-template-columns: 2fr 3fr 2fr;
            height: calc(100vh - 60px);
            gap: 1px;
            background: rgba(255, 255, 255, 0.05);
        }

        .panel {
            background: rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .panel-header {
            background: rgba(0, 0, 0, 0.3);
            padding: 0.75rem 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            font-weight: 600;
            font-size: 0.9rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .panel-content {
            flex: 1;
            overflow: hidden;
            position: relative;
        }

        /* Transcript Panel */
        .transcript-log {
            height: 100%;
            overflow-y: auto;
            padding: 1rem;
            font-size: 0.85rem;
            line-height: 1.6;
            scroll-behavior: smooth;
        }

        .transcript-line {
            margin-bottom: 0.5rem;
            padding: 0.25rem 0;
            border-left: 2px solid transparent;
            padding-left: 0.5rem;
            transition: all 0.3s ease;
        }

        .transcript-line.recent {
            border-left-color: #00d4ff;
            background: rgba(0, 212, 255, 0.05);
            animation: fadeIn 0.5s ease;
        }

        .timestamp {
            color: #888;
            font-size: 0.75rem;
            margin-right: 0.5rem;
        }

        /* Answer Detail Panel */
        .answer-detail {
            height: 100%;
            overflow-y: auto;
            padding: 1rem;
            font-size: 0.9rem;
            line-height: 1.7;
        }

        .answer-question {
            color: #00d4ff;
            font-weight: 600;
            margin-bottom: 1rem;
            padding: 0.5rem;
            background: rgba(0, 212, 255, 0.1);
            border-radius: 6px;
            border-left: 3px solid #00d4ff;
        }

        .answer-content {
            color: #e6e6e6;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .answer-pending {
            color: #ffd93d;
            font-style: italic;
            animation: blink 1.5s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.5; }
        }

        /* Questions Table */
        .qa-table-container {
            height: 100%;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .qa-table {
            flex: 1;
            overflow-y: auto;
        }

        .qa-row {
            display: grid;
            grid-template-columns: 80px 1fr 120px;
            padding: 0.75rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.85rem;
        }

        .qa-row:hover {
            background: rgba(255, 255, 255, 0.05);
        }

        .qa-row.selected {
            background: rgba(0, 212, 255, 0.15);
            border-left: 3px solid #00d4ff;
        }

        .qa-status {
            display: flex;
            align-items: center;
            gap: 0.3rem;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .qa-status.pending {
            color: #ffd93d;
        }

        .qa-status.answered {
            color: #00ff88;
        }

        .qa-question {
            color: #e6e6e6;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding-right: 0.5rem;
        }

        .qa-preview {
            color: #aaa;
            font-size: 0.75rem;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* Controls */
        .controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 0.5rem;
            z-index: 1000;
        }

        .control-btn {
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #e6e6e6;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.2s ease;
            font-family: inherit;
        }

        .control-btn:hover {
            background: rgba(0, 212, 255, 0.2);
            border-color: #00d4ff;
            transform: translateY(-1px);
        }

        .control-btn.active {
            background: rgba(0, 212, 255, 0.3);
            border-color: #00d4ff;
            color: #00d4ff;
        }

        /* Ask Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .modal-overlay.show {
            opacity: 1;
            visibility: visible;
        }

        .modal {
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 2rem;
            min-width: 400px;
            max-width: 600px;
        }

        .modal h3 {
            color: #00d4ff;
            margin-bottom: 1rem;
            font-size: 1.1rem;
        }

        .modal input {
            width: 100%;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            padding: 0.75rem;
            color: #e6e6e6;
            font-family: inherit;
            font-size: 0.9rem;
        }

        .modal input:focus {
            outline: none;
            border-color: #00d4ff;
            box-shadow: 0 0 0 2px rgba(0, 212, 255, 0.2);
        }

        .modal-buttons {
            margin-top: 1rem;
            display: flex;
            gap: 0.5rem;
            justify-content: flex-end;
        }

        /* Scrollbars */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .fade-in {
            animation: fadeIn 0.3s ease;
        }

        /* Mobile responsiveness */
        @media (max-width: 768px) {
            .main-container {
                grid-template-columns: 1fr;
                grid-template-rows: 1fr 1fr 1fr;
            }
            
            .header h1 {
                font-size: 1rem;
            }
            
            .status-indicators {
                font-size: 0.7rem;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üé§ STT Interview Panel</h1>
        <div class="status-indicators">
            <div class="status-item">
                <div id="ws-status" class="status-dot status-disconnected"></div>
                <span id="ws-text">Connecting...</span>
            </div>
            <div class="status-item">
                <div id="autoscroll-status" class="status-dot"></div>
                <span>Auto-Scroll</span>
            </div>
            <div class="status-item">
                <div id="follow-status" class="status-dot status-follow"></div>
                <span>Follow Latest</span>
            </div>
            <div class="status-item">
                <span id="qa-count">QAs: 0 (pending: 0)</span>
            </div>
			    <button id="start">Partager l‚Äôonglet (avec audio)</button>
    <button id="stop" disabled>Stop</button>
	
    <pre id="log"></pre>

        </div>
    </div>

    <div class="license-bar">
        <div class="license-status" id="license-state">Trial not started</div>
        <div class="license-status" id="trial-timer">30:00</div>
        <input id="license-key" class="license-input" type="text" placeholder="License key (XXXX-XXXX-XXXX-XXXX-XXXX)" />
        <button id="license-activate" class="license-btn">Activate</button>
        <button id="trial-start" class="license-btn secondary">Start 30-min trial</button>
        <a class="license-link" href="/" target="_blank">Pricing</a>
    </div>

    <div class="main-container">
        <!-- Transcript Panel -->
        <div class="panel">
            <div class="panel-header">
                <span>üìù Transcript</span>
                <span id="transcript-info">Waiting for audio...</span>
            </div>
            <div class="panel-content">
                <div id="transcript-log" class="transcript-log">
                    <div class="transcript-line">
                        <span class="timestamp">[--:--:--]</span>
                        <span>Waiting for audio stream...</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Answer Detail Panel -->
        <div class="panel">
            <div class="panel-header">
                <span>üí° Answer Details</span>
                <span id="detail-info">Select a question to view details</span>
            </div>
            <div class="panel-content">
                <div id="answer-detail" class="answer-detail">
                    <div style="text-align: center; color: #888; margin-top: 2rem;">
                        Select a question from the right panel or ask a new one to see the detailed answer here.
                    </div>
                </div>
            </div>
        </div>

        <!-- Questions & Answers Panel -->
        <div class="panel">
            <div class="panel-header">
                <span>‚ùì Questions & Answers</span>
                <span id="qa-info">Ready</span>
            </div>
            <div class="panel-content">
                <div class="qa-table-container">
                    <div id="qa-table" class="qa-table">
                        <!-- Questions will be populated here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Controls -->
    <div class="controls">
        <button class="control-btn" onclick="toggleAutoScroll()" title="Toggle auto-scroll (p)">üìú Auto</button>
        <button class="control-btn active" onclick="toggleFollow()" title="Follow latest question (f)">üëÅÔ∏è Follow</button>
        <button class="control-btn" onclick="askQuestion()" title="Ask a question (a)">‚ùì Ask</button>
        <button class="control-btn" onclick="resetView()" title="Reset view (r)">üîÑ Reset</button>
        <button class="control-btn" onclick="saveSnapshot()" title="Save snapshot (s)">üíæ Save</button>
    </div>

    <!-- Ask Modal -->
    <div id="ask-modal" class="modal-overlay">
        <div class="modal">
            <h3>Ask a Question</h3>
            <input type="text" id="question-input" placeholder="Type your question here..." />
            <div class="modal-buttons">
                <button class="control-btn" onclick="closeAskModal()">Cancel</button>
                <button class="control-btn" onclick="submitQuestion()">Ask</button>
            </div>
        </div>
    </div>

    <script>
        const DEFAULT_WS_URL = 'wss://stt.trotski.cc/';

        function getWsUrl() {
            const params = new URLSearchParams(window.location.search);
            return params.get('ws') || DEFAULT_WS_URL;
        }

        const TRIAL_MINUTES = 30;
        const TRIAL_STORAGE_KEY = 'trotski_trial_start';
        const LICENSE_STORAGE_KEY = 'trotski_license_key';
        let licenseActive = false;

        function getStoredLicenseKey() {
            return (localStorage.getItem(LICENSE_STORAGE_KEY) || '').trim();
        }

        function setStoredLicenseKey(key) {
            const clean = (key || '').trim().toUpperCase();
            if (clean) {
                localStorage.setItem(LICENSE_STORAGE_KEY, clean);
            }
            return clean;
        }

        function formatRemaining(seconds) {
            const mins = Math.max(0, Math.floor(seconds / 60));
            const secs = Math.max(0, seconds % 60);
            return `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
        }

        function getLocalTrialRemaining() {
            const startMs = parseInt(localStorage.getItem(TRIAL_STORAGE_KEY) || '0', 10);
            if (!startMs) return null;
            const totalSec = TRIAL_MINUTES * 60;
            const elapsed = Math.floor((Date.now() - startMs) / 1000);
            return Math.max(0, totalSec - elapsed);
        }

        function setTrialStartFromRemaining(remainingSec) {
            const totalSec = TRIAL_MINUTES * 60;
            const startMs = Date.now() - Math.max(0, totalSec - remainingSec) * 1000;
            localStorage.setItem(TRIAL_STORAGE_KEY, String(startMs));
        }

        function updateTrialUi(remainingSec) {
            const timerEl = document.getElementById('trial-timer');
            const statusEl = document.getElementById('license-state');
            const trialBtn = document.getElementById('trial-start');

            if (licenseActive) {
                statusEl.textContent = 'License active';
                timerEl.textContent = '';
                return;
            }

            if (remainingSec == null) {
                statusEl.textContent = 'Trial not started';
                timerEl.textContent = `${TRIAL_MINUTES}:00`;
                if (trialBtn) trialBtn.disabled = false;
                return;
            }

            if (remainingSec <= 0) {
                statusEl.textContent = 'Trial expired';
                timerEl.textContent = '00:00';
                if (trialBtn) trialBtn.disabled = true;
                return;
            }

            statusEl.textContent = 'Trial active';
            timerEl.textContent = formatRemaining(remainingSec);
            if (trialBtn) trialBtn.disabled = true;
        }

        function startLocalTrial() {
            if (getLocalTrialRemaining() != null) return;
            localStorage.setItem(TRIAL_STORAGE_KEY, String(Date.now()));
            updateTrialUi(getLocalTrialRemaining());
        }

        function updateLicenseState(valid) {
            licenseActive = Boolean(valid);
            updateTrialUi(getLocalTrialRemaining());
        }

        function trialExpired() {
            if (licenseActive) return false;
            const remaining = getLocalTrialRemaining();
            return remaining !== null && remaining <= 0;
        }

        function canUseTrial() {
            if (licenseActive) return true;
            const remaining = getLocalTrialRemaining();
            return remaining !== null && remaining > 0;
        }
class STTInterviewPanel {
  constructor() {
    this.ws = null;
    this.state = {
      transcript: '',
      qas: [],              // [{id: qid, q, a, ...}]
      pending: new Set(),
      connected: false,
      autoScroll: false,
      followLatest: true,
      selectedIndex: -1
    };
    this.qaById = new Map(); // üëà index rapide par qid
    this.seenIds = new Set(); // üëà √©viter doublons par id
    this.seenQuestions = new Set(); // legacy (texte)
    this.reconnectTimeout = null;
    this.init();
  }

            init() {
                this.setupKeyboardShortcuts();
                this.connectWebSocket();
                this.updateUI();
            }

            setupKeyboardShortcuts() {
                document.addEventListener('keydown', (e) => {
                    if (e.target.tagName === 'INPUT') return;
                    
                    switch(e.key.toLowerCase()) {
                        case 'a': this.askQuestion(); break;
                        case 'p': this.toggleAutoScroll(); break;
                        case 'f': this.toggleFollow(); break;
                        case 'r': this.resetView(); break;
                        case 's': this.saveSnapshot(); break;
                        case 'g': this.scrollTranscriptHome(); break;
                        case 'j': this.selectNext(); break;
                        case 'k': this.selectPrevious(); break;
                        case 'escape': this.closeAskModal(); break;
                    }
                    
                    if (e.key === 'G' && e.shiftKey) {
                        this.scrollTranscriptEnd();
                    }
                });
            }

            connectWebSocket() {
                const wsUrl = getWsUrl();
                console.log(`Connecting to ${wsUrl}`);
                
                try {
                    this.ws = new WebSocket(wsUrl);
                    
                    this.ws.onopen = () => {
                        console.log('WebSocket connected');
                        this.state.connected = true;
                        const key = getStoredLicenseKey();
                        if (key) {
                            this.ws.send(JSON.stringify({ cmd: 'license', key }));
                        }
                        this.updateConnectionStatus();
                        if (this.reconnectTimeout) {
                            clearTimeout(this.reconnectTimeout);
                            this.reconnectTimeout = null;
                        }
                    };
                    
                    this.ws.onclose = () => {
                        console.log('WebSocket disconnected');
                        this.state.connected = false;
                        this.updateConnectionStatus();
                        this.scheduleReconnect();
                    };
                    
                    this.ws.onerror = (error) => {
                        console.error('WebSocket error:', error);
                    };
                    
                    this.ws.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            this.handleMessage(data);
                        } catch (e) {
                            console.error('Failed to parse message:', e);
                        }
                    };
                } catch (error) {
                    console.error('Failed to create WebSocket:', error);
                    this.scheduleReconnect();
                }
            }

            scheduleReconnect() {
                if (this.reconnectTimeout) return;
                
                this.reconnectTimeout = setTimeout(() => {
                    console.log('Attempting to reconnect...');
                    this.connectWebSocket();
                }, 3000);
            }


handleLine(line) {
  const text = (line && line.text) ? line.text.trim() : '';
  if (!text) return;

  // retire la ligne partielle si elle existe
  const ghost = document.getElementById('partial-line');
  if (ghost && ghost.parentNode) ghost.parentNode.removeChild(ghost);

  this.state.transcript = (this.state.transcript ? this.state.transcript + ' ' : '') + text;
  this.renderTranscriptLine(text);  // r√©utilise ton renderer existant
  this.updateUI();
}


            handleMessage(data) {
                if (data.trial) {
                    const remaining = Number(data.trial.remaining_sec || 0);
                    if (remaining > 0) {
                        setTrialStartFromRemaining(remaining);
                    }
                    updateTrialUi(getLocalTrialRemaining());
                } else if (data.license) {
                    const statusEl = document.getElementById('license-state');
                    if (data.license === 'valid') {
                        updateLicenseState(true);
                    } else {
                        if (statusEl) statusEl.textContent = 'License invalid';
                        updateLicenseState(false);
                    }
                } else if (data.error) {
                    const statusEl = document.getElementById('license-state');
                    if (statusEl && data.message) statusEl.textContent = data.message;
                    updateTrialUi(getLocalTrialRemaining());
                } else if (data.snapshot) {
                    this.handleSnapshot(data.snapshot);
                } else if (data.partial) {
                    this.handlePartial(data.partial);
                } else if (data.question_detected) {
                    this.handleQuestionDetected(data.question_detected);
                } else if (data.qa) {
                    this.handleQA(data.qa);
                }
				 else if (data.line) { // üëà AJOUT
    this.handleLine(data.line);
  }
            }

		handleSnapshot(snapshot) {
		  // üëá utilise les lignes commit√©es si pr√©sentes
		  const lines = Array.isArray(snapshot.lines) ? snapshot.lines : [];
		  const committed = lines.join(' ');
		  const partial   = snapshot.transcript || '';

		  this.state.transcript = (committed + (partial ? (' ' + partial) : '')).trim();

		  this.state.qas = (snapshot.detected || []).map(item => ({
			q: item.q,
			a: item.a || null,
			t: item.t,
			pending: !item.a
		  }));
		  this.state.pending.clear();
		  this.state.qas.forEach(qa => { if (qa.pending) this.state.pending.add(qa.q); });

		  this.renderAll();
		}


            handlePartial(text) {
                this.state.transcript = (this.state.transcript + ' ' + text).trim();
                this.renderTranscriptLine(text);
                this.updateUI();
            }

  handleQuestionDetected(payload) {
    const qid = payload.qid || null;
    const q   = payload.q;
    if (!q) return;

    // üëá anti-doublon par id en priorit√©
    if (qid && this.seenIds.has(qid)) return;
    if (!qid && this.seenQuestions.has(q)) return;

    const qaItem = {
      id: qid || ('q-' + Math.random().toString(36).slice(2)),
      q: q,
      a: null,
      t: payload.t || Date.now(),
      pending: true,
      context: payload.context || '',
      urgency: payload.urgency || 'optional',
      confidence: payload.confidence ?? 0.5
    };

    this.state.qas.push(qaItem);
    this.qaById.set(qaItem.id, qaItem);
    if (qid) this.seenIds.add(qid); else this.seenQuestions.add(q);
    this.state.pending.add(qaItem.id);

    this.renderQuestion(qaItem);
    this.updateUI();

    if (this.state.followLatest) {
      this.selectQuestion(this.state.qas.length - 1);
    }
  }

  handleQA(payload) {
    const id = payload.qid || null;
    const q  = payload.q || '';
    const a  = payload.a || null;
    if (!a) return;

    let qaItem = id ? this.qaById.get(id) : null;
    if (!qaItem) {
      // fallback par texte si pas d'id
      qaItem = this.state.qas.find(it => it.q === q);
      if (!qaItem) {
        // cr√©er si vraiment jamais vu (rare)
        qaItem = {
          id: id || ('q-' + Math.random().toString(36).slice(2)),
          q, a: null, t: payload.t || Date.now(), pending: true
        };
        this.state.qas.push(qaItem);
        this.qaById.set(qaItem.id, qaItem);
      }
    }

    qaItem.a = a;
    qaItem.pending = false;
    this.state.pending.delete(qaItem.id);

    // Re-render ligne & d√©tail si s√©lectionn√©e
    this.renderQuestion(qaItem);
    if (this.state.selectedIndex >= 0 &&
        this.state.qas[this.state.selectedIndex] === qaItem) {
      this.renderAnswerDetail(qaItem);
    }
    this.updateUI();
  }

            renderAll() {
                this.renderTranscript();
                this.renderQuestions();
                this.updateUI();
                if (this.state.qas.length > 0 && this.state.followLatest) {
                    this.selectQuestion(this.state.qas.length - 1);
                }
            }

            renderTranscript() {
                const log = document.getElementById('transcript-log');
                log.innerHTML = '';
                
                if (!this.state.transcript) {
                    log.innerHTML = '<div class="transcript-line"><span class="timestamp">[--:--:--]</span><span>Waiting for audio stream...</span></div>';
                    return;
                }
                
                const sentences = this.state.transcript.split(/(?<=[.!?])\s+/);
                sentences.forEach((sentence, index) => {
                    if (sentence.trim()) {
                        const lines = this.wrapText(sentence.trim(), 80);
                        lines.forEach((line, lineIndex) => {
                            const div = document.createElement('div');
                            div.className = 'transcript-line';
                            if (index === sentences.length - 1) {
                                div.classList.add('recent');
                            }
                            
                            const timestamp = lineIndex === 0 ? this.formatTimestamp() : '         ';
                            div.innerHTML = `<span class="timestamp">${timestamp}</span><span>${line}</span>`;
                            log.appendChild(div);
                        });
                    }
                });
                
                if (this.state.autoScroll) {
                    log.scrollTop = log.scrollHeight;
                }
            }

            renderTranscriptLine(text) {
                const log = document.getElementById('transcript-log');
                const lines = this.wrapText(text.trim(), 80);
                
                lines.forEach((line, index) => {
                    const div = document.createElement('div');
                    div.className = 'transcript-line recent fade-in';
                    
                    const timestamp = index === 0 ? this.formatTimestamp() : '         ';
                    div.innerHTML = `<span class="timestamp">${timestamp}</span><span>${line}</span>`;
                    log.appendChild(div);
                });
                
                // Remove 'recent' class after animation
                setTimeout(() => {
                    document.querySelectorAll('.transcript-line.recent').forEach(el => {
                        el.classList.remove('recent');
                    });
                }, 3000);
                
                if (this.state.autoScroll) {
                    log.scrollTop = log.scrollHeight;
                }
            }

            renderQuestions() {
                const table = document.getElementById('qa-table');
                table.innerHTML = '';
                
                this.state.qas.forEach((qa, index) => {
                    this.renderQuestion(qa, index);
                });
            }

            renderQuestion(qa, index = null) {
                if (index === null) {
                    index = this.state.qas.indexOf(qa);
                }
                
                const table = document.getElementById('qa-table');
                let row = table.children[index];
                
                if (!row) {
                    row = document.createElement('div');
                    row.className = 'qa-row fade-in';
                    row.onclick = () => this.selectQuestion(index);
                    table.appendChild(row);
                }
                
                const status = qa.pending ? 'pending' : 'answered';
                const statusText = qa.pending ? '‚è≥ pending' : '‚úÖ answered';
                const preview = qa.a ? this.truncateText(qa.a, 50) : '(pending...)';
                
                row.innerHTML = `
                    <div class="qa-status ${status}">${statusText}</div>
                    <div class="qa-question" title="${qa.q}">${qa.q}</div>
                    <div class="qa-preview" title="${preview}">${preview}</div>
                `;
                
                if (index === this.state.selectedIndex) {
                    row.classList.add('selected');
                } else {
                    row.classList.remove('selected');
                }
            }

            selectQuestion(index) {
                if (index < 0 || index >= this.state.qas.length) return;
                
                // Remove previous selection
                document.querySelectorAll('.qa-row').forEach(row => {
                    row.classList.remove('selected');
                });
                
                // Add new selection
                this.state.selectedIndex = index;
                const row = document.getElementById('qa-table').children[index];
                if (row) {
                    row.classList.add('selected');
                    row.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
                
                this.renderAnswerDetail(this.state.qas[index]);
            }

            renderAnswerDetail(qa) {
                const detail = document.getElementById('answer-detail');
                
                if (!qa) {
                    detail.innerHTML = `
                        <div style="text-align: center; color: #888; margin-top: 2rem;">
                            Select a question from the right panel or ask a new one to see the detailed answer here.
                        </div>
                    `;
                    return;
                }
                
                const answerContent = qa.a || 'Generating answer...';
                const answerClass = qa.pending ? 'answer-pending' : '';
                
                detail.innerHTML = `
                    <div class="answer-question">Q: ${qa.q}</div>
                    <div class="answer-content ${answerClass}">${answerContent}</div>
                `;
            }

            updateUI() {
                this.updateConnectionStatus();
                this.updateCounters();
                this.updateControlStates();
            }

            updateConnectionStatus() {
                const wsStatus = document.getElementById('ws-status');
                const wsText = document.getElementById('ws-text');
                
                if (this.state.connected) {
                    wsStatus.className = 'status-dot status-connected';
                    wsText.textContent = 'Connected';
                } else {
                    wsStatus.className = 'status-dot status-disconnected';
                    wsText.textContent = 'Disconnected';
                }
            }

            updateCounters() {
                const qaCount = document.getElementById('qa-count');
                const pendingCount = this.state.pending.size;
                qaCount.textContent = `QAs: ${this.state.qas.length} (pending: ${pendingCount})`;
            }

            updateControlStates() {
                const autoScrollBtn = document.querySelector('[onclick="toggleAutoScroll()"]');
                const followBtn = document.querySelector('[onclick="toggleFollow()"]');
                const autoScrollStatus = document.getElementById('autoscroll-status');
                const followStatus = document.getElementById('follow-status');
                
                if (this.state.autoScroll) {
                    autoScrollBtn.classList.add('active');
                    autoScrollStatus.className = 'status-dot status-auto-scroll';
                } else {
                    autoScrollBtn.classList.remove('active');
                    autoScrollStatus.className = 'status-dot';
                }
                
                if (this.state.followLatest) {
                    followBtn.classList.add('active');
                    followStatus.className = 'status-dot status-follow';
                } else {
                    followBtn.classList.remove('active');
                    followStatus.className = 'status-dot';
                }
            }

            // Utility methods
            formatTimestamp() {
                const now = new Date();
                return `[${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}]`;
            }

            wrapText(text, maxLength) {
                if (text.length <= maxLength) return [text];
                
                const words = text.split(' ');
                const lines = [];
                let currentLine = '';
                
                for (const word of words) {
                    if ((currentLine + ' ' + word).length <= maxLength) {
                        currentLine = currentLine ? currentLine + ' ' + word : word;
                    } else {
                        if (currentLine) lines.push(currentLine);
                        currentLine = word;
                    }
                }
                
                if (currentLine) lines.push(currentLine);
                return lines;
            }

            truncateText(text, maxLength) {
                if (text.length <= maxLength) return text;
                return text.substring(0, maxLength) + '...';
            }

            // Control methods
            toggleAutoScroll() {
                this.state.autoScroll = !this.state.autoScroll;
                if (this.state.autoScroll) {
                    const log = document.getElementById('transcript-log');
                    log.scrollTop = log.scrollHeight;
                }
                this.updateUI();
            }

            toggleFollow() {
                this.state.followLatest = !this.state.followLatest;
                this.updateUI();
            }

            resetView() {
                this.state.transcript = '';
                this.state.qas = [];
                this.state.pending.clear();
                this.state.selectedIndex = -1;
                this.seenQuestions.clear();
                
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify({ cmd: 'reset' }));
                }
                
                this.renderAll();
            }

            saveSnapshot() {
                const data = {
                    timestamp: new Date().toISOString(),
                    transcript: this.state.transcript,
                    qas: this.state.qas
                };
                
                const markdown = this.generateMarkdownReport(data);
                const blob = new Blob([markdown], { type: 'text/markdown' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `stt_interview_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.md`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                // Show feedback
                this.showNotification('Snapshot saved!', 'success');
            }

            generateMarkdownReport(data) {
                let markdown = `# STT Interview Report\n\n`;
                markdown += `**Generated:** ${data.timestamp}\n\n`;
                
                if (data.transcript) {
                    markdown += `## üìù Transcript\n\n${data.transcript}\n\n`;
                }
                
                if (data.qas.length > 0) {
                    markdown += `## ‚ùì Questions & Answers\n\n`;
                    data.qas.forEach((qa, index) => {
                        markdown += `### ${index + 1}. ${qa.q}\n\n`;
                        markdown += `${qa.a || '*Answer pending...*'}\n\n`;
                        markdown += `---\n\n`;
                    });
                }
                
                return markdown;
            }

            askQuestion() {
                const modal = document.getElementById('ask-modal');
                const input = document.getElementById('question-input');
                modal.classList.add('show');
                input.focus();
                input.value = '';
            }

            closeAskModal() {
                const modal = document.getElementById('ask-modal');
                modal.classList.remove('show');
            }

submitQuestion() {
  const input = document.getElementById('question-input');
  const question = input.value.trim();
  if (!question) return this.showNotification('Please enter a question', 'warning');

  const qid = crypto?.randomUUID ? crypto.randomUUID() : ('q-' + Date.now() + '-' + Math.random().toString(36).slice(2));

  // Ajouter une ligne "pending" locale tout de suite
  const qaItem = { id: qid, q: question, a: null, t: Date.now(), pending: true };
  this.state.qas.push(qaItem);
  this.qaById.set(qid, qaItem);
  this.state.pending.add(qid);
  this.seenIds.add(qid);
  this.renderQuestion(qaItem);
  this.updateUI();
  if (this.state.followLatest) this.selectQuestion(this.state.qas.length - 1);

  // Envoyer au serveur
  if (this.ws && this.ws.readyState === WebSocket.OPEN) {
    this.ws.send(JSON.stringify({ cmd: 'ask', qid, q: question }));
  } else {
    // Fallback: on pr√©vient qu'il n'y a pas de WS
    qaItem.a = '[offline] WebSocket not connected.';
    qaItem.pending = false;
    this.state.pending.delete(qid);
    this.renderQuestion(qaItem);
    this.renderAnswerDetail(qaItem);
  }

  this.closeAskModal();
  this.showNotification('Question submitted!', 'success');
}


            simulateAnswer(question) {
                // Simulate delay for answer generation
                setTimeout(() => {
                    const answers = [
                        "This is a great question. Based on current best practices, I'd recommend focusing on scalability and maintainability. The key tradeoff is between development speed and long-term technical debt.",
                        "From a technical perspective, there are several approaches to consider. The most effective solution would be to implement a hybrid approach that balances performance with flexibility. Trade-off: Higher initial complexity for better long-term adaptability.",
                        "This requires careful consideration of the requirements and constraints. I'd suggest starting with a proof-of-concept to validate the approach before full implementation. Trade-off: More upfront research time versus reduced risk of costly mistakes.",
                        "The answer depends on your specific context and goals. Generally, I'd recommend following industry standards while adapting to your unique requirements. Trade-off: Standardization benefits versus customization needs."
                    ];
                    
                    const randomAnswer = answers[Math.floor(Math.random() * answers.length)];
                    
                    const qaItem = this.state.qas.find(item => item.q === question);
                    if (qaItem && qaItem.pending) {
                        qaItem.a = randomAnswer;
                        qaItem.pending = false;
                        this.state.pending.delete(question);
                        this.renderQuestion(qaItem);
                        
                        if (this.state.selectedIndex >= 0 && 
                            this.state.qas[this.state.selectedIndex] === qaItem) {
                            this.renderAnswerDetail(qaItem);
                        }
                        
                        this.updateUI();
                        this.showNotification('Answer received!', 'success');
                    }
                }, 2000 + Math.random() * 3000); // Random delay 2-5 seconds
            }

            scrollTranscriptHome() {
                const log = document.getElementById('transcript-log');
                log.scrollTop = 0;
            }

            scrollTranscriptEnd() {
                const log = document.getElementById('transcript-log');
                log.scrollTop = log.scrollHeight;
            }

            selectNext() {
                if (this.state.qas.length === 0) return;
                const newIndex = Math.min(this.state.selectedIndex + 1, this.state.qas.length - 1);
                this.selectQuestion(newIndex);
            }

            selectPrevious() {
                if (this.state.qas.length === 0) return;
                const newIndex = Math.max(this.state.selectedIndex - 1, 0);
                this.selectQuestion(newIndex);
            }

            showNotification(message, type = 'info') {
                // Create notification element
                const notification = document.createElement('div');
                notification.className = `notification notification-${type}`;
                notification.textContent = message;
                notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: ${type === 'success' ? 'rgba(0, 255, 136, 0.2)' : 
                                 type === 'warning' ? 'rgba(255, 217, 61, 0.2)' : 
                                 'rgba(0, 212, 255, 0.2)'};
                    border: 1px solid ${type === 'success' ? '#00ff88' : 
                                       type === 'warning' ? '#ffd93d' : 
                                       '#00d4ff'};
                    color: ${type === 'success' ? '#00ff88' : 
                             type === 'warning' ? '#ffd93d' : 
                             '#00d4ff'};
                    padding: 1rem 1.5rem;
                    border-radius: 6px;
                    backdrop-filter: blur(10px);
                    z-index: 3000;
                    font-family: inherit;
                    font-size: 0.9rem;
                    animation: slideIn 0.3s ease, fadeOut 0.3s ease 2.7s forwards;
                `;
                
                // Add animation styles
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes slideIn {
                        from { transform: translateX(100%); opacity: 0; }
                        to { transform: translateX(0); opacity: 1; }
                    }
                    @keyframes fadeOut {
                        from { opacity: 1; }
                        to { opacity: 0; }
                    }
                `;
                document.head.appendChild(style);
                
                document.body.appendChild(notification);
                
                // Remove after animation
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                    if (style.parentNode) {
                        style.parentNode.removeChild(style);
                    }
                }, 3000);
            }
        }

        // Global functions for buttons
        let panel;

        function toggleAutoScroll() {
            panel.toggleAutoScroll();
        }

        function toggleFollow() {
            panel.toggleFollow();
        }

        function askQuestion() {
            panel.askQuestion();
        }

        function resetView() {
            panel.resetView();
        }

        function saveSnapshot() {
            panel.saveSnapshot();
        }

        function closeAskModal() {
            panel.closeAskModal();
        }

        function submitQuestion() {
            panel.submitQuestion();
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', () => {
            panel = new STTInterviewPanel();

            const licenseInput = document.getElementById('license-key');
            const licenseBtn = document.getElementById('license-activate');
            const trialBtn = document.getElementById('trial-start');

            if (licenseInput) {
                licenseInput.value = getStoredLicenseKey();
            }

            if (licenseBtn) {
                licenseBtn.addEventListener('click', () => {
                    const key = setStoredLicenseKey(licenseInput?.value || '');
                    if (!key) return;
                    if (panel?.ws && panel.ws.readyState === WebSocket.OPEN) {
                        panel.ws.send(JSON.stringify({ cmd: 'license', key }));
                    }
                    if (audioWs && audioWs.readyState === WebSocket.OPEN) {
                        audioWs.send(JSON.stringify({ cmd: 'license', key }));
                    }
                });
            }

            if (trialBtn) {
                trialBtn.addEventListener('click', () => {
                    startLocalTrial();
                });
            }

            updateTrialUi(getLocalTrialRemaining());
            setInterval(() => updateTrialUi(getLocalTrialRemaining()), 1000);
            
            // Handle Enter key in ask modal
            document.getElementById('question-input').addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    submitQuestion();
                } else if (e.key === 'Escape') {
                    closeAskModal();
                }
            });
            
            // Close modal when clicking outside
            document.getElementById('ask-modal').addEventListener('click', (e) => {
                if (e.target.classList.contains('modal-overlay')) {
                    closeAskModal();
                }
            });
        });
		const log = m => { console.log(m); const el = document.getElementById('log'); if (el) el.textContent += m + '\n'; };

let stream;
let audioCtx;
let sourceNode;
let node;
let audioWs;
let pullGain; // pour ‚Äútirer‚Äù le graphe sans son

function secureContextOk() {
  if (location.protocol === 'https:' || location.hostname === 'localhost' || location.hostname === '127.0.0.1') return true;
  return false;
}

async function tryGetDisplay(constraints, label) {
  log(`‚Üí try getDisplayMedia: ${label}  ${JSON.stringify(constraints)}`);
  return await navigator.mediaDevices.getDisplayMedia(constraints);
}

async function startShare() {
  if (!licenseActive && !canUseTrial()) {
    alert('Start the 30-minute trial or enter a license key to continue.');
    return;
  }
  if (trialExpired()) {
    alert('Trial expired. Please enter a license key to continue.');
    return;
  }
  if (!('mediaDevices' in navigator) || !('getDisplayMedia' in navigator.mediaDevices)) {
    log('‚ùå getDisplayMedia non disponible dans ce navigateur.');
    return;
  }
  if (!secureContextOk()) {
    log('‚ùå Contexte non s√©curis√© (utilise http://localhost ou https://).');
    return;
  }

  const startBtn = document.getElementById('start');
  const stopBtn  = document.getElementById('stop');

  try {
    // 1) Minimal (le plus compatible) ‚Äî on laisse l‚Äôutilisateur cocher ‚Äúpartager le son de l‚Äôonglet‚Äù
    try {
      stream = await tryGetDisplay({ video: true, audio: true }, 'minimal audio:true');
    } catch (e1) {
      log(`fail minimal: ${e1.name} ${e1.message}`);

      // 2) Tentative ‚Äúm√™me onglet‚Äù (Chromium r√©cents uniquement)
      // Peut jeter NotSupportedError si la combo n‚Äôest pas dispo sur l‚ÄôOS/version
      try {
        stream = await tryGetDisplay({
          video: true,
          audio: { selfBrowserSurface: "include", suppressLocalAudioPlayback: false }
        }, 'selfBrowserSurface');
      } catch (e2) {
        log(`fail selfBrowserSurface: ${e2.name} ${e2.message}`);

        // 3) Windows: ‚Äú√âcran entier‚Äù + audio syst√®me (selon version Chromium)
        try {
          stream = await tryGetDisplay({ video: true, audio: { systemAudio: "include" } }, 'systemAudio');
        } catch (e3) {
          log(`fail systemAudio: ${e3.name} ${e3.message}`);

          // 4) Ultime fallback: micro
          log('Fallback microphone‚Ä¶ (onglet non support√© pour l‚Äôaudio ici)');
          stream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
        }
      }
    }

    // V√©rifier qu‚Äôon a bien de l‚Äôaudio
    if (stream.getAudioTracks().length === 0) {
      log('‚ö†Ô∏è Pas de piste audio dans le stream. Dans le picker, s√©lectionne ‚ÄúOnglet Chrome‚Äù ET coche ‚ÄúPartager le son de l‚Äôonglet‚Äù.');
    }

  audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 48000 });
  await audioCtx.audioWorklet.addModule('./pcm-16k-worklet.js');

  sourceNode = audioCtx.createMediaStreamSource(stream);

  // cr√©e le Worklet et configure
  node = new AudioWorkletNode(audioCtx, 'pcm16k-writer', {
    numberOfInputs: 1,
    numberOfOutputs: 1, // on sort du silence mais on garde 1 output pour que le graphe soit ‚Äúpull√©‚Äù
    channelCount: 1,
    processorOptions: { targetSampleRate: 16000, chunkMs: 100 }
  });

  // Tirer le graphe sans faire de son (gain=0)
  pullGain = audioCtx.createGain();
  pullGain.gain.value = 0;

  sourceNode.connect(node);
  node.connect(pullGain);
  pullGain.connect(audioCtx.destination);

  // WS binaire vers ton serveur STT
  const wsUrl = getWsUrl();
  audioWs = new WebSocket(wsUrl);
  audioWs.binaryType = 'arraybuffer';
  audioWs.onopen = () => {
    const key = getStoredLicenseKey();
    if (key) {
      audioWs.send(JSON.stringify({ cmd: 'license', key }));
    }
    // informe le serveur que c‚Äôest un ‚Äúingest‚Äù (il coupe les broadcasts)
    audioWs.send(JSON.stringify({ cmd: 'hello', client: 'ingest' }));
    log('üîó WS audio connect√©');
  };
  audioWs.onerror = (e) => log('WS audio error: ' + e.message);
  audioWs.onclose = () => log('WS audio ferm√©');

  // R√©ception des chunks PCM16 du worklet ‚Üí envoi WS
  node.port.onmessage = (ev) => {
    const { type, payload } = ev.data || {};
    if (type === 'chunk' && payload && audioWs && audioWs.readyState === WebSocket.OPEN) {
      audioWs.send(payload); // payload est un ArrayBuffer de PCM16LE 16k mono
    }
  };

  // Reprise de l‚ÄôaudioCtx (politique auto-play)
  if (audioCtx.state === 'suspended') await audioCtx.resume();

    startBtn.disabled = true;
    stopBtn.disabled = false;

    // Quand l‚Äôutilisateur stoppe via l‚ÄôUI syst√®me
    (stream.getVideoTracks()[0] || stream.getAudioTracks()[0])?.addEventListener('ended', stopShare);

    log('‚úÖ Capture d√©marr√©e. Si tu as choisi ‚ÄúOnglet Chrome‚Äù, coche bien ‚ÄúPartager le son de l‚Äôonglet‚Äù.');
  } catch (err) {
    log(`Erreur start: ${err.name}: ${err.message}`);
    if (err.name === 'NotAllowedError') log('Le navigateur a bloqu√© l‚Äôacc√®s: relance apr√®s un clic et autorise le partage.');
    if (err.name === 'NotSupportedError') log('Combo non support√©e ici. Essaie Chrome/Edge √† jour, Brave (Shields off), ou ‚Äú√âcran entier‚Äù + audio syst√®me.');
  }
}

function stopShare() {
  try { sourceNode && sourceNode.disconnect(); } catch {}
  try { audioCtx && audioCtx.close(); } catch {}
  if (stream) { stream.getTracks().forEach(t => t.stop()); }
  stream = null; sourceNode = null; audioCtx = null;
  document.getElementById('start').disabled = false;
  document.getElementById('stop').disabled = true;
  log('üõë Capture arr√™t√©e.');
}

document.getElementById('start').addEventListener('click', startShare);
document.getElementById('stop').addEventListener('click', stopShare);
    </script>
	
</body>
</html>
