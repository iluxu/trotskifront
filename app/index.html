<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trotski Live Interview Panel</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;600;700&family=JetBrains+Mono:wght@400;600&display=swap');

        :root {
            --bg: #0a0b14;
            --panel: rgba(12, 14, 24, 0.9);
            --panel-strong: rgba(18, 20, 34, 0.95);
            --ink: #e9f0ff;
            --muted: #9aa3c7;
            --neon: #4ef1ff;
            --neon-2: #8aff6a;
            --hot: #ff5ec4;
            --line: rgba(255, 255, 255, 0.08);
        }

        body {
            font-family: 'Space Grotesk', system-ui, sans-serif;
            background:
                radial-gradient(900px 500px at 15% 0%, rgba(78, 241, 255, 0.18), transparent 60%),
                radial-gradient(700px 400px at 85% 10%, rgba(255, 94, 196, 0.2), transparent 55%),
                linear-gradient(180deg, #090a12 0%, #0b0c16 60%, #090a12 100%);
            color: var(--ink);
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: rgba(10, 12, 22, 0.75);
            backdrop-filter: blur(14px);
            border-bottom: 1px solid rgba(78, 241, 255, 0.12);
            padding: 0.9rem 1.5rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header h1 {
            font-size: 1.25rem;
            font-weight: 700;
            letter-spacing: 0.02em;
            color: var(--neon);
            text-shadow: 0 0 20px rgba(78, 241, 255, 0.4);
        }

        .status-indicators {
            display: flex;
            gap: 1rem;
            font-size: 0.8rem;
            color: var(--muted);
        }

        .quickstart {
            font-size: 0.85rem;
            color: var(--muted);
            padding: 0.6rem 1.5rem;
            border-bottom: 1px solid var(--line);
            background: rgba(10, 12, 22, 0.6);
        }

        .capture-controls {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 0.6rem;
            padding: 0.6rem 1.5rem;
            border-bottom: 1px solid var(--line);
            background: rgba(12, 14, 24, 0.8);
        }

        .capture-btn {
            background: linear-gradient(135deg, var(--neon), var(--hot));
            color: #0b0c16;
            border: none;
            padding: 0.45rem 0.8rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 600;
        }

        .capture-btn.secondary {
            background: rgba(6, 8, 14, 0.8);
            color: var(--ink);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .capture-log {
            flex: 1 1 240px;
            min-width: 220px;
            max-height: 90px;
            overflow: auto;
            font-size: 0.8rem;
            color: var(--muted);
            background: rgba(6, 8, 14, 0.7);
            padding: 0.45rem 0.6rem;
            border-radius: 6px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            font-family: 'JetBrains Mono', ui-monospace, monospace;
        }

        .license-bar {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 0.6rem;
            padding: 0.7rem 1.5rem;
            border-bottom: 1px solid var(--line);
            background: rgba(8, 10, 18, 0.75);
        }

        .license-status {
            font-size: 0.85rem;
            color: var(--neon-2);
            margin-right: 0.5rem;
        }

        .license-input {
            background: rgba(6, 8, 14, 0.8);
            border: 1px solid rgba(78, 241, 255, 0.2);
            color: var(--ink);
            padding: 0.4rem 0.6rem;
            border-radius: 6px;
            min-width: 240px;
        }

        .license-btn {
            background: linear-gradient(135deg, var(--neon), var(--hot));
            color: #0b0c16;
            border: none;
            padding: 0.45rem 0.8rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85rem;
            font-weight: 600;
        }

        .license-btn.secondary {
            background: rgba(6, 8, 14, 0.8);
            color: var(--ink);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .license-link {
            color: var(--neon-2);
            text-decoration: none;
            font-size: 0.85rem;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        .status-connected { background: var(--neon-2); }
        .status-disconnected { background: #ff5e5e; }
        .status-auto-scroll { background: var(--neon); }
        .status-follow { background: #8a7dff; }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .main-container {
            display: grid;
            grid-template-columns: 2fr 3fr 2fr;
            flex: 1;
            min-height: 0;
            gap: 1px;
            background: rgba(255, 255, 255, 0.04);
        }

        .panel {
            background: var(--panel);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(78, 241, 255, 0.08);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .panel-header {
            background: var(--panel-strong);
            padding: 0.75rem 1rem;
            border-bottom: 1px solid rgba(78, 241, 255, 0.1);
            font-weight: 600;
            font-size: 0.9rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .panel-content {
            flex: 1;
            overflow: hidden;
            position: relative;
        }

        /* Transcript Panel */
        .transcript-log {
            height: 100%;
            overflow-y: auto;
            padding: 1rem;
            font-size: 0.85rem;
            line-height: 1.6;
            scroll-behavior: smooth;
            font-family: 'JetBrains Mono', ui-monospace, monospace;
        }

        .transcript-line {
            margin-bottom: 0.5rem;
            padding: 0.25rem 0;
            border-left: 2px solid transparent;
            padding-left: 0.5rem;
            transition: all 0.3s ease;
        }

        .transcript-line.recent {
            border-left-color: var(--neon);
            background: rgba(78, 241, 255, 0.06);
            animation: fadeIn 0.5s ease;
        }

        .timestamp {
            color: #888;
            font-size: 0.75rem;
            margin-right: 0.5rem;
        }

        /* Answer Detail Panel */
        .answer-detail {
            height: 100%;
            overflow-y: auto;
            padding: 1rem;
            font-size: 0.95rem;
            line-height: 1.7;
        }

        .answer-question {
            color: var(--neon);
            font-weight: 600;
            margin-bottom: 1rem;
            padding: 0.5rem;
            background: rgba(78, 241, 255, 0.12);
            border-radius: 6px;
            border-left: 3px solid var(--neon);
        }

        .answer-content {
            color: var(--ink);
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .answer-pending {
            color: #ffd93d;
            font-style: italic;
            animation: blink 1.5s infinite;
        }

        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.5; }
        }

        /* Questions Table */
        .qa-table-container {
            height: 100%;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .qa-table {
            flex: 1;
            overflow-y: auto;
        }

        .qa-row {
            display: grid;
            grid-template-columns: 80px 1fr 120px;
            padding: 0.75rem;
            border-bottom: 1px solid rgba(78, 241, 255, 0.06);
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.85rem;
        }

        .qa-row:hover {
            background: rgba(78, 241, 255, 0.08);
        }

        .qa-row.selected {
            background: rgba(78, 241, 255, 0.16);
            border-left: 3px solid var(--neon);
        }

        .qa-status {
            display: flex;
            align-items: center;
            gap: 0.3rem;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .qa-status.pending {
            color: #ffd93d;
        }

        .qa-status.answered {
            color: var(--neon-2);
        }

        .qa-question {
            color: var(--ink);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            padding-right: 0.5rem;
        }

        .qa-preview {
            color: var(--muted);
            font-size: 0.75rem;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        /* Controls */
        .controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            gap: 0.5rem;
            z-index: 1000;
        }

        .control-btn {
            background: rgba(6, 8, 14, 0.9);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(78, 241, 255, 0.2);
            color: var(--ink);
            padding: 0.5rem 1rem;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.2s ease;
            font-family: inherit;
        }

        .control-btn:hover {
            background: rgba(78, 241, 255, 0.16);
            border-color: var(--neon);
            transform: translateY(-1px);
        }

        .control-btn.active {
            background: rgba(78, 241, 255, 0.22);
            border-color: var(--neon);
            color: var(--neon);
        }

        /* Ask Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(5px);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }

        .modal-overlay.show {
            opacity: 1;
            visibility: visible;
        }

        .modal {
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            padding: 2rem;
            min-width: 400px;
            max-width: 600px;
        }

        .modal h3 {
            color: #00d4ff;
            margin-bottom: 1rem;
            font-size: 1.1rem;
        }

        .modal input {
            width: 100%;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            padding: 0.75rem;
            color: #e6e6e6;
            font-family: inherit;
            font-size: 0.9rem;
        }

        .modal input:focus {
            outline: none;
            border-color: #00d4ff;
            box-shadow: 0 0 0 2px rgba(0, 212, 255, 0.2);
        }

        .modal-buttons {
            margin-top: 1rem;
            display: flex;
            gap: 0.5rem;
            justify-content: flex-end;
        }

        /* Scrollbars */
        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        /* Animations */
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .fade-in {
            animation: fadeIn 0.3s ease;
        }

        /* Mobile responsiveness */
        @media (max-width: 768px) {
            .main-container {
                grid-template-columns: 1fr;
                grid-template-rows: 1fr 1fr 1fr;
            }
            
            .header h1 {
                font-size: 1rem;
            }
            
            .status-indicators {
                font-size: 0.7rem;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Trotski Live Interview Panel</h1>
        <div class="status-indicators">
            <div class="status-item">
                <div id="ws-status" class="status-dot status-disconnected"></div>
                <span id="ws-text">Connecting...</span>
            </div>
            <div class="status-item">
                <div id="autoscroll-status" class="status-dot"></div>
                <span>Auto-Scroll</span>
            </div>
            <div class="status-item">
                <div id="follow-status" class="status-dot status-follow"></div>
                <span>Follow Latest</span>
            </div>
            <div class="status-item">
                <span id="qa-count">QAs: 0 (pending: 0)</span>
            </div>
        </div>
    </div>

    <div class="license-bar">
        <div class="license-status" id="license-state">Trial not started</div>
        <div class="license-status" id="trial-timer">30:00</div>
        <input id="license-key" class="license-input" type="text" placeholder="License key (XXXX-XXXX-XXXX-XXXX-XXXX)" />
        <button id="license-activate" class="license-btn">Activate</button>
        <button id="trial-start" class="license-btn secondary">Start 30-min trial</button>
        <a class="license-link" href="/" target="_blank">Pricing</a>
    </div>

    <div class="quickstart">Quick start: 1) Start 30-min trial or enter a license 2) Click Share tab with audio (tab audio only, no microphone) 3) Speak and watch the transcript.</div>

    <div class="capture-controls">
        <button id="start" class="capture-btn">Share tab with audio</button>
        <button id="stop" class="capture-btn secondary" disabled>Stop capture</button>
        <pre id="log" class="capture-log">Waiting for audio stream...</pre>
    </div>

    <div class="main-container">
        <!-- Transcript Panel -->
        <div class="panel">
            <div class="panel-header">
                <span>Transcript</span>
                <span id="transcript-info">Waiting for audio...</span>
            </div>
            <div class="panel-content">
                <div id="transcript-log" class="transcript-log">
                    <div class="transcript-line">
                        <span class="timestamp">[--:--:--]</span>
                        <span>Waiting for audio stream...</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Answer Detail Panel -->
        <div class="panel">
            <div class="panel-header">
                <span>Answer Details</span>
                <span id="detail-info">Select a question to view details</span>
            </div>
            <div class="panel-content">
                <div id="answer-detail" class="answer-detail">
                    <div style="text-align: center; color: #888; margin-top: 2rem;">
                        Select a question from the right panel or ask a new one to see the detailed answer here.
                    </div>
                </div>
            </div>
        </div>

        <!-- Questions & Answers Panel -->
        <div class="panel">
            <div class="panel-header">
                <span>Questions & Answers</span>
                <span id="qa-info">Ready</span>
            </div>
            <div class="panel-content">
                <div class="qa-table-container">
                    <div id="qa-table" class="qa-table">
                        <!-- Questions will be populated here -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Controls -->
    <div class="controls">
        <button class="control-btn" onclick="toggleAutoScroll()" title="Toggle auto-scroll (p)">Auto</button>
        <button class="control-btn active" onclick="toggleFollow()" title="Follow latest question (f)">Follow</button>
        <button class="control-btn" onclick="askQuestion()" title="Ask a question (a)">Ask</button>
        <button class="control-btn" onclick="resetView()" title="Reset view (r)">Reset</button>
        <button class="control-btn" onclick="saveSnapshot()" title="Save snapshot (s)">Save</button>
    </div>

    <!-- Ask Modal -->
    <div id="ask-modal" class="modal-overlay">
        <div class="modal">
            <h3>Ask a Question</h3>
            <input type="text" id="question-input" placeholder="Type your question here..." />
            <div class="modal-buttons">
                <button class="control-btn" onclick="closeAskModal()">Cancel</button>
                <button class="control-btn" onclick="submitQuestion()">Ask</button>
            </div>
        </div>
    </div>

    <script>
        const DEFAULT_WS_URL = 'wss://trotski.fly.dev/';

        function getWsUrl() {
            const params = new URLSearchParams(window.location.search);
            return params.get('ws') || DEFAULT_WS_URL;
        }

        const TRIAL_MINUTES = 30;
        const TRIAL_STORAGE_KEY = 'trotski_trial_start';
        const LICENSE_STORAGE_KEY = 'trotski_license_key';
        let licenseActive = false;

        function getStoredLicenseKey() {
            return (localStorage.getItem(LICENSE_STORAGE_KEY) || '').trim();
        }

        function setStoredLicenseKey(key) {
            const clean = (key || '').trim().toUpperCase();
            if (clean) {
                localStorage.setItem(LICENSE_STORAGE_KEY, clean);
            }
            return clean;
        }

        function formatRemaining(seconds) {
            const mins = Math.max(0, Math.floor(seconds / 60));
            const secs = Math.max(0, seconds % 60);
            return `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
        }

        function getLocalTrialRemaining() {
            const startMs = parseInt(localStorage.getItem(TRIAL_STORAGE_KEY) || '0', 10);
            if (!startMs) return null;
            const totalSec = TRIAL_MINUTES * 60;
            const elapsed = Math.floor((Date.now() - startMs) / 1000);
            return Math.max(0, totalSec - elapsed);
        }

        function setTrialStartFromRemaining(remainingSec) {
            const totalSec = TRIAL_MINUTES * 60;
            const startMs = Date.now() - Math.max(0, totalSec - remainingSec) * 1000;
            localStorage.setItem(TRIAL_STORAGE_KEY, String(startMs));
        }

        function updateTrialUi(remainingSec) {
            const timerEl = document.getElementById('trial-timer');
            const statusEl = document.getElementById('license-state');
            const trialBtn = document.getElementById('trial-start');

            if (licenseActive) {
                statusEl.textContent = 'License active';
                timerEl.textContent = '';
                return;
            }

            if (remainingSec == null) {
                statusEl.textContent = 'Trial not started';
                timerEl.textContent = `${TRIAL_MINUTES}:00`;
                if (trialBtn) trialBtn.disabled = false;
                return;
            }

            if (remainingSec <= 0) {
                statusEl.textContent = 'Trial expired';
                timerEl.textContent = '00:00';
                if (trialBtn) trialBtn.disabled = true;
                return;
            }

            statusEl.textContent = 'Trial active';
            timerEl.textContent = formatRemaining(remainingSec);
            if (trialBtn) trialBtn.disabled = true;
        }

        function startLocalTrial() {
            if (getLocalTrialRemaining() != null) return;
            localStorage.setItem(TRIAL_STORAGE_KEY, String(Date.now()));
            updateTrialUi(getLocalTrialRemaining());
        }

        function updateLicenseState(valid) {
            licenseActive = Boolean(valid);
            updateTrialUi(getLocalTrialRemaining());
        }

        function trialExpired() {
            if (licenseActive) return false;
            const remaining = getLocalTrialRemaining();
            return remaining !== null && remaining <= 0;
        }

        function canUseTrial() {
            if (licenseActive) return true;
            const remaining = getLocalTrialRemaining();
            return remaining !== null && remaining > 0;
        }
class STTInterviewPanel {
  constructor() {
    this.ws = null;
    this.state = {
      transcript: '',
      qas: [],              // [{id: qid, q, a, ...}]
      pending: new Set(),
      connected: false,
      autoScroll: true,
      followLatest: true,
      selectedIndex: -1
    };
    this.qaById = new Map(); // quick index by qid
    this.seenIds = new Set(); // avoid duplicates by id
    this.seenQuestions = new Set(); // legacy (texte)
    this.reconnectTimeout = null;
    this.init();
  }

            init() {
                this.setupKeyboardShortcuts();
                this.connectWebSocket();
                this.updateUI();
            }

            setupKeyboardShortcuts() {
                document.addEventListener('keydown', (e) => {
                    if (e.target.tagName === 'INPUT') return;
                    
                    switch(e.key.toLowerCase()) {
                        case 'a': this.askQuestion(); break;
                        case 'p': this.toggleAutoScroll(); break;
                        case 'f': this.toggleFollow(); break;
                        case 'r': this.resetView(); break;
                        case 's': this.saveSnapshot(); break;
                        case 'g': this.scrollTranscriptHome(); break;
                        case 'j': this.selectNext(); break;
                        case 'k': this.selectPrevious(); break;
                        case 'escape': this.closeAskModal(); break;
                    }
                    
                    if (e.key === 'G' && e.shiftKey) {
                        this.scrollTranscriptEnd();
                    }
                });
            }

            connectWebSocket() {
                const wsUrl = getWsUrl();
                console.log(`Connecting to ${wsUrl}`);
                
                try {
                    this.ws = new WebSocket(wsUrl);
                    
                    this.ws.onopen = () => {
                        console.log('WebSocket connected');
                        this.state.connected = true;
                        const key = getStoredLicenseKey();
                        if (key) {
                            this.ws.send(JSON.stringify({ cmd: 'license', key }));
                        }
                        this.updateConnectionStatus();
                        if (this.reconnectTimeout) {
                            clearTimeout(this.reconnectTimeout);
                            this.reconnectTimeout = null;
                        }
                    };
                    
                    this.ws.onclose = () => {
                        console.log('WebSocket disconnected');
                        this.state.connected = false;
                        this.updateConnectionStatus();
                        this.scheduleReconnect();
                    };
                    
                    this.ws.onerror = (error) => {
                        console.error('WebSocket error:', error);
                    };
                    
                    this.ws.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);
                            this.handleMessage(data);
                        } catch (e) {
                            console.error('Failed to parse message:', e);
                        }
                    };
                } catch (error) {
                    console.error('Failed to create WebSocket:', error);
                    this.scheduleReconnect();
                }
            }

            scheduleReconnect() {
                if (this.reconnectTimeout) return;
                
                this.reconnectTimeout = setTimeout(() => {
                    console.log('Attempting to reconnect...');
                    this.connectWebSocket();
                }, 3000);
            }


handleLine(line) {
  const text = (line && line.text) ? line.text.trim() : '';
  if (!text) return;

  // retire la ligne partielle si elle existe
  const ghost = document.getElementById('partial-line');
  if (ghost && ghost.parentNode) ghost.parentNode.removeChild(ghost);

  this.state.transcript = (this.state.transcript ? this.state.transcript + ' ' : '') + text;
  this.renderTranscriptLine(text);  // reuse existing renderer
  this.updateUI();
}


            handleMessage(data) {
                if (data.trial) {
                    const remaining = Number(data.trial.remaining_sec || 0);
                    if (remaining > 0) {
                        setTrialStartFromRemaining(remaining);
                    }
                    updateTrialUi(getLocalTrialRemaining());
                } else if (data.license) {
                    const statusEl = document.getElementById('license-state');
                    if (data.license === 'valid') {
                        updateLicenseState(true);
                    } else {
                        if (statusEl) statusEl.textContent = 'License invalid';
                        updateLicenseState(false);
                    }
                } else if (data.error) {
                    const statusEl = document.getElementById('license-state');
                    if (statusEl && data.message) statusEl.textContent = data.message;
                    updateTrialUi(getLocalTrialRemaining());
                } else if (data.snapshot) {
                    this.handleSnapshot(data.snapshot);
                } else if (data.partial) {
                    this.handlePartial(data.partial);
                } else if (data.question_detected) {
                    this.handleQuestionDetected(data.question_detected);
                } else if (data.qa) {
                    this.handleQA(data.qa);
                }
				 else if (data.line) { // additional line handling
    this.handleLine(data.line);
  }
            }

		handleSnapshot(snapshot) {
		  // use committed lines when available
		  const lines = Array.isArray(snapshot.lines) ? snapshot.lines : [];
		  const committed = lines.join(' ');
		  const partial   = snapshot.transcript || '';

		  this.state.transcript = (committed + (partial ? (' ' + partial) : '')).trim();

		  this.state.qas = (snapshot.detected || []).map(item => ({
			q: item.q,
			a: item.a || null,
			t: item.t,
			pending: !item.a
		  }));
		  this.state.pending.clear();
		  this.state.qas.forEach(qa => { if (qa.pending) this.state.pending.add(qa.q); });

		  this.renderAll();
		}


            handlePartial(text) {
                this.state.transcript = (this.state.transcript + ' ' + text).trim();
                this.renderTranscriptLine(text);
                this.updateUI();
            }

  handleQuestionDetected(payload) {
    const qid = payload.qid || null;
    const q   = payload.q;
    if (!q) return;

    // de-duplicate by id first
    if (qid && this.seenIds.has(qid)) return;
    if (!qid && this.seenQuestions.has(q)) return;

    const qaItem = {
      id: qid || ('q-' + Math.random().toString(36).slice(2)),
      q: q,
      a: null,
      t: payload.t || Date.now(),
      pending: true,
      context: payload.context || '',
      urgency: payload.urgency || 'optional',
      confidence: payload.confidence ?? 0.5
    };

    this.state.qas.push(qaItem);
    this.qaById.set(qaItem.id, qaItem);
    if (qid) this.seenIds.add(qid); else this.seenQuestions.add(q);
    this.state.pending.add(qaItem.id);

    this.renderQuestion(qaItem);
    this.updateUI();

    if (this.state.followLatest) {
      this.selectQuestion(this.state.qas.length - 1);
    }
  }

  handleQA(payload) {
    const id = payload.qid || null;
    const q  = payload.q || '';
    const a  = payload.a || null;
    if (!a) return;

    let qaItem = id ? this.qaById.get(id) : null;
    if (!qaItem) {
      // fallback par texte si pas d'id
      qaItem = this.state.qas.find(it => it.q === q);
      if (!qaItem) {
        // create if never seen (rare)
        qaItem = {
          id: id || ('q-' + Math.random().toString(36).slice(2)),
          q, a: null, t: payload.t || Date.now(), pending: true
        };
        this.state.qas.push(qaItem);
        this.qaById.set(qaItem.id, qaItem);
      }
    }

    qaItem.a = a;
    qaItem.pending = false;
    this.state.pending.delete(qaItem.id);

    // re-render line and detail if selected
    this.renderQuestion(qaItem);
    if (this.state.selectedIndex >= 0 &&
        this.state.qas[this.state.selectedIndex] === qaItem) {
      this.renderAnswerDetail(qaItem);
    }
    this.updateUI();
  }

            renderAll() {
                this.renderTranscript();
                this.renderQuestions();
                this.updateUI();
                if (this.state.qas.length > 0 && this.state.followLatest) {
                    this.selectQuestion(this.state.qas.length - 1);
                }
            }

            renderTranscript() {
                const log = document.getElementById('transcript-log');
                log.innerHTML = '';
                
                if (!this.state.transcript) {
                    log.innerHTML = '<div class="transcript-line"><span class="timestamp">[--:--:--]</span><span>Waiting for audio stream...</span></div>';
                    return;
                }
                
                const sentences = this.state.transcript.split(/(?<=[.!?])\s+/);
                sentences.forEach((sentence, index) => {
                    if (sentence.trim()) {
                        const lines = this.wrapText(sentence.trim(), 80);
                        lines.forEach((line, lineIndex) => {
                            const div = document.createElement('div');
                            div.className = 'transcript-line';
                            if (index === sentences.length - 1) {
                                div.classList.add('recent');
                            }
                            
                            const timestamp = lineIndex === 0 ? this.formatTimestamp() : '         ';
                            div.innerHTML = `<span class="timestamp">${timestamp}</span><span>${line}</span>`;
                            log.appendChild(div);
                        });
                    }
                });
                
                if (this.state.autoScroll) {
                    log.scrollTop = log.scrollHeight;
                }
            }

            renderTranscriptLine(text) {
                const log = document.getElementById('transcript-log');
                const lines = this.wrapText(text.trim(), 80);
                
                lines.forEach((line, index) => {
                    const div = document.createElement('div');
                    div.className = 'transcript-line recent fade-in';
                    
                    const timestamp = index === 0 ? this.formatTimestamp() : '         ';
                    div.innerHTML = `<span class="timestamp">${timestamp}</span><span>${line}</span>`;
                    log.appendChild(div);
                });
                
                // Remove 'recent' class after animation
                setTimeout(() => {
                    document.querySelectorAll('.transcript-line.recent').forEach(el => {
                        el.classList.remove('recent');
                    });
                }, 3000);
                
                if (this.state.autoScroll) {
                    log.scrollTop = log.scrollHeight;
                }
            }

            renderQuestions() {
                const table = document.getElementById('qa-table');
                table.innerHTML = '';
                
                this.state.qas.forEach((qa, index) => {
                    this.renderQuestion(qa, index);
                });
            }

            renderQuestion(qa, index = null) {
                if (index === null) {
                    index = this.state.qas.indexOf(qa);
                }
                
                const table = document.getElementById('qa-table');
                let row = table.children[index];
                
                if (!row) {
                    row = document.createElement('div');
                    row.className = 'qa-row fade-in';
                    row.onclick = () => this.selectQuestion(index);
                    table.appendChild(row);
                }
                
                const status = qa.pending ? 'pending' : 'answered';
                const statusText = qa.pending ? 'pending' : 'answered';
                const preview = qa.a ? this.truncateText(qa.a, 50) : '(pending...)';
                
                row.innerHTML = `
                    <div class="qa-status ${status}">${statusText}</div>
                    <div class="qa-question" title="${qa.q}">${qa.q}</div>
                    <div class="qa-preview" title="${preview}">${preview}</div>
                `;
                
                if (index === this.state.selectedIndex) {
                    row.classList.add('selected');
                } else {
                    row.classList.remove('selected');
                }
            }

            selectQuestion(index) {
                if (index < 0 || index >= this.state.qas.length) return;
                
                // Remove previous selection
                document.querySelectorAll('.qa-row').forEach(row => {
                    row.classList.remove('selected');
                });
                
                // Add new selection
                this.state.selectedIndex = index;
                const row = document.getElementById('qa-table').children[index];
                if (row) {
                    row.classList.add('selected');
                    row.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
                
                this.renderAnswerDetail(this.state.qas[index]);
            }

            renderAnswerDetail(qa) {
                const detail = document.getElementById('answer-detail');
                
                if (!qa) {
                    detail.innerHTML = `
                        <div style="text-align: center; color: #888; margin-top: 2rem;">
                            Select a question from the right panel or ask a new one to see the detailed answer here.
                        </div>
                    `;
                    return;
                }
                
                const answerContent = qa.a || 'Generating answer...';
                const answerClass = qa.pending ? 'answer-pending' : '';
                
                detail.innerHTML = `
                    <div class="answer-question">Q: ${qa.q}</div>
                    <div class="answer-content ${answerClass}">${answerContent}</div>
                `;
            }

            updateUI() {
                this.updateConnectionStatus();
                this.updateCounters();
                this.updateControlStates();
            }

            updateConnectionStatus() {
                const wsStatus = document.getElementById('ws-status');
                const wsText = document.getElementById('ws-text');
                
                if (this.state.connected) {
                    wsStatus.className = 'status-dot status-connected';
                    wsText.textContent = 'Connected';
                } else {
                    wsStatus.className = 'status-dot status-disconnected';
                    wsText.textContent = 'Disconnected';
                }
            }

            updateCounters() {
                const qaCount = document.getElementById('qa-count');
                const pendingCount = this.state.pending.size;
                qaCount.textContent = `QAs: ${this.state.qas.length} (pending: ${pendingCount})`;
            }

            updateControlStates() {
                const autoScrollBtn = document.querySelector('[onclick="toggleAutoScroll()"]');
                const followBtn = document.querySelector('[onclick="toggleFollow()"]');
                const autoScrollStatus = document.getElementById('autoscroll-status');
                const followStatus = document.getElementById('follow-status');
                
                if (this.state.autoScroll) {
                    autoScrollBtn.classList.add('active');
                    autoScrollStatus.className = 'status-dot status-auto-scroll';
                } else {
                    autoScrollBtn.classList.remove('active');
                    autoScrollStatus.className = 'status-dot';
                }
                
                if (this.state.followLatest) {
                    followBtn.classList.add('active');
                    followStatus.className = 'status-dot status-follow';
                } else {
                    followBtn.classList.remove('active');
                    followStatus.className = 'status-dot';
                }
            }

            // Utility methods
            formatTimestamp() {
                const now = new Date();
                return `[${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}]`;
            }

            wrapText(text, maxLength) {
                if (text.length <= maxLength) return [text];
                
                const words = text.split(' ');
                const lines = [];
                let currentLine = '';
                
                for (const word of words) {
                    if ((currentLine + ' ' + word).length <= maxLength) {
                        currentLine = currentLine ? currentLine + ' ' + word : word;
                    } else {
                        if (currentLine) lines.push(currentLine);
                        currentLine = word;
                    }
                }
                
                if (currentLine) lines.push(currentLine);
                return lines;
            }

            truncateText(text, maxLength) {
                if (text.length <= maxLength) return text;
                return text.substring(0, maxLength) + '...';
            }

            // Control methods
            toggleAutoScroll() {
                this.state.autoScroll = !this.state.autoScroll;
                if (this.state.autoScroll) {
                    const log = document.getElementById('transcript-log');
                    log.scrollTop = log.scrollHeight;
                }
                this.updateUI();
            }

            toggleFollow() {
                this.state.followLatest = !this.state.followLatest;
                this.updateUI();
            }

            resetView() {
                this.state.transcript = '';
                this.state.qas = [];
                this.state.pending.clear();
                this.state.selectedIndex = -1;
                this.seenQuestions.clear();
                
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify({ cmd: 'reset' }));
                }
                
                this.renderAll();
            }

            saveSnapshot() {
                const data = {
                    timestamp: new Date().toISOString(),
                    transcript: this.state.transcript,
                    qas: this.state.qas
                };
                
                const markdown = this.generateMarkdownReport(data);
                const blob = new Blob([markdown], { type: 'text/markdown' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `stt_interview_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.md`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                // Show feedback
                this.showNotification('Snapshot saved!', 'success');
            }

            generateMarkdownReport(data) {
                let markdown = `# STT Interview Report\n\n`;
                markdown += `**Generated:** ${data.timestamp}\n\n`;
                
                if (data.transcript) {
                    markdown += `## Transcript\n\n${data.transcript}\n\n`;
                }
                
                if (data.qas.length > 0) {
                    markdown += `## Questions & Answers\n\n`;
                    data.qas.forEach((qa, index) => {
                        markdown += `### ${index + 1}. ${qa.q}\n\n`;
                        markdown += `${qa.a || '*Answer pending...*'}\n\n`;
                        markdown += `---\n\n`;
                    });
                }
                
                return markdown;
            }

            askQuestion() {
                const modal = document.getElementById('ask-modal');
                const input = document.getElementById('question-input');
                modal.classList.add('show');
                input.focus();
                input.value = '';
            }

            closeAskModal() {
                const modal = document.getElementById('ask-modal');
                modal.classList.remove('show');
            }

submitQuestion() {
  const input = document.getElementById('question-input');
  const question = input.value.trim();
  if (!question) return this.showNotification('Please enter a question', 'warning');

  const qid = crypto?.randomUUID ? crypto.randomUUID() : ('q-' + Date.now() + '-' + Math.random().toString(36).slice(2));

  // Ajouter une ligne "pending" locale tout de suite
  const qaItem = { id: qid, q: question, a: null, t: Date.now(), pending: true };
  this.state.qas.push(qaItem);
  this.qaById.set(qid, qaItem);
  this.state.pending.add(qid);
  this.seenIds.add(qid);
  this.renderQuestion(qaItem);
  this.updateUI();
  if (this.state.followLatest) this.selectQuestion(this.state.qas.length - 1);

  // Envoyer au serveur
  if (this.ws && this.ws.readyState === WebSocket.OPEN) {
    this.ws.send(JSON.stringify({ cmd: 'ask', qid, q: question }));
  } else {
    // Fallback: warn when WS is unavailable
    qaItem.a = '[offline] WebSocket not connected.';
    qaItem.pending = false;
    this.state.pending.delete(qid);
    this.renderQuestion(qaItem);
    this.renderAnswerDetail(qaItem);
  }

  this.closeAskModal();
  this.showNotification('Question submitted!', 'success');
}


            simulateAnswer(question) {
                // Simulate delay for answer generation
                setTimeout(() => {
                    const answers = [
                        "This is a great question. Based on current best practices, I'd recommend focusing on scalability and maintainability. The key tradeoff is between development speed and long-term technical debt.",
                        "From a technical perspective, there are several approaches to consider. The most effective solution would be to implement a hybrid approach that balances performance with flexibility. Trade-off: Higher initial complexity for better long-term adaptability.",
                        "This requires careful consideration of the requirements and constraints. I'd suggest starting with a proof-of-concept to validate the approach before full implementation. Trade-off: More upfront research time versus reduced risk of costly mistakes.",
                        "The answer depends on your specific context and goals. Generally, I'd recommend following industry standards while adapting to your unique requirements. Trade-off: Standardization benefits versus customization needs."
                    ];
                    
                    const randomAnswer = answers[Math.floor(Math.random() * answers.length)];
                    
                    const qaItem = this.state.qas.find(item => item.q === question);
                    if (qaItem && qaItem.pending) {
                        qaItem.a = randomAnswer;
                        qaItem.pending = false;
                        this.state.pending.delete(question);
                        this.renderQuestion(qaItem);
                        
                        if (this.state.selectedIndex >= 0 && 
                            this.state.qas[this.state.selectedIndex] === qaItem) {
                            this.renderAnswerDetail(qaItem);
                        }
                        
                        this.updateUI();
                        this.showNotification('Answer received!', 'success');
                    }
                }, 2000 + Math.random() * 3000); // Random delay 2-5 seconds
            }

            scrollTranscriptHome() {
                const log = document.getElementById('transcript-log');
                log.scrollTop = 0;
            }

            scrollTranscriptEnd() {
                const log = document.getElementById('transcript-log');
                log.scrollTop = log.scrollHeight;
            }

            selectNext() {
                if (this.state.qas.length === 0) return;
                const newIndex = Math.min(this.state.selectedIndex + 1, this.state.qas.length - 1);
                this.selectQuestion(newIndex);
            }

            selectPrevious() {
                if (this.state.qas.length === 0) return;
                const newIndex = Math.max(this.state.selectedIndex - 1, 0);
                this.selectQuestion(newIndex);
            }

            showNotification(message, type = 'info') {
                // Create notification element
                const notification = document.createElement('div');
                notification.className = `notification notification-${type}`;
                notification.textContent = message;
                notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: ${type === 'success' ? 'rgba(0, 255, 136, 0.2)' : 
                                 type === 'warning' ? 'rgba(255, 217, 61, 0.2)' : 
                                 'rgba(0, 212, 255, 0.2)'};
                    border: 1px solid ${type === 'success' ? '#00ff88' : 
                                       type === 'warning' ? '#ffd93d' : 
                                       '#00d4ff'};
                    color: ${type === 'success' ? '#00ff88' : 
                             type === 'warning' ? '#ffd93d' : 
                             '#00d4ff'};
                    padding: 1rem 1.5rem;
                    border-radius: 6px;
                    backdrop-filter: blur(10px);
                    z-index: 3000;
                    font-family: inherit;
                    font-size: 0.9rem;
                    animation: slideIn 0.3s ease, fadeOut 0.3s ease 2.7s forwards;
                `;
                
                // Add animation styles
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes slideIn {
                        from { transform: translateX(100%); opacity: 0; }
                        to { transform: translateX(0); opacity: 1; }
                    }
                    @keyframes fadeOut {
                        from { opacity: 1; }
                        to { opacity: 0; }
                    }
                `;
                document.head.appendChild(style);
                
                document.body.appendChild(notification);
                
                // Remove after animation
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                    if (style.parentNode) {
                        style.parentNode.removeChild(style);
                    }
                }, 3000);
            }
        }

        // Global functions for buttons
        let panel;

        function toggleAutoScroll() {
            panel.toggleAutoScroll();
        }

        function toggleFollow() {
            panel.toggleFollow();
        }

        function askQuestion() {
            panel.askQuestion();
        }

        function resetView() {
            panel.resetView();
        }

        function saveSnapshot() {
            panel.saveSnapshot();
        }

        function closeAskModal() {
            panel.closeAskModal();
        }

        function submitQuestion() {
            panel.submitQuestion();
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', () => {
            panel = new STTInterviewPanel();

            const licenseInput = document.getElementById('license-key');
            const licenseBtn = document.getElementById('license-activate');
            const trialBtn = document.getElementById('trial-start');

            if (licenseInput) {
                licenseInput.value = getStoredLicenseKey();
            }

            if (licenseBtn) {
                licenseBtn.addEventListener('click', () => {
                    const key = setStoredLicenseKey(licenseInput?.value || '');
                    if (!key) return;
                    if (panel?.ws && panel.ws.readyState === WebSocket.OPEN) {
                        panel.ws.send(JSON.stringify({ cmd: 'license', key }));
                    }
                    if (audioWs && audioWs.readyState === WebSocket.OPEN) {
                        audioWs.send(JSON.stringify({ cmd: 'license', key }));
                    }
                });
            }

            if (trialBtn) {
                trialBtn.addEventListener('click', () => {
                    startLocalTrial();
                });
            }

            updateTrialUi(getLocalTrialRemaining());
            setInterval(() => updateTrialUi(getLocalTrialRemaining()), 1000);
            
            // Handle Enter key in ask modal
            document.getElementById('question-input').addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    submitQuestion();
                } else if (e.key === 'Escape') {
                    closeAskModal();
                }
            });
            
            // Close modal when clicking outside
            document.getElementById('ask-modal').addEventListener('click', (e) => {
                if (e.target.classList.contains('modal-overlay')) {
                    closeAskModal();
                }
            });
        });
		const log = m => { console.log(m); const el = document.getElementById('log'); if (el) el.textContent += m + '\n'; };

let stream;
let audioCtx;
let sourceNode;
let node;
let audioWs;
let pullGain; // keep graph alive without audio output

function secureContextOk() {
  if (location.protocol === 'https:' || location.hostname === 'localhost' || location.hostname === '127.0.0.1') return true;
  return false;
}

async function tryGetDisplay(constraints, label) {
  log(`try getDisplayMedia: ${label}  ${JSON.stringify(constraints)}`);
  return await navigator.mediaDevices.getDisplayMedia(constraints);
}

async function startShare() {
  if (!licenseActive && !canUseTrial()) {
    alert('Start the 30-minute trial or enter a license key to continue.');
    return;
  }
  if (trialExpired()) {
    alert('Trial expired. Please enter a license key to continue.');
    return;
  }
  if (!('mediaDevices' in navigator) || !('getDisplayMedia' in navigator.mediaDevices)) {
    log('getDisplayMedia is not available in this browser.');
    return;
  }
  if (!secureContextOk()) {
    log('Insecure context. Use https:// or http://localhost.');
    return;
  }

  const startBtn = document.getElementById('start');
  const stopBtn  = document.getElementById('stop');

  try {
    stream = await tryGetDisplay({ video: true, audio: true }, 'tab audio');
    const videoTrack = stream.getVideoTracks()[0];
    const surface = videoTrack?.getSettings?.().displaySurface;
    if (surface && surface !== 'browser') {
      log('Tab audio only. Please select a browser tab and enable Share tab audio.');
      stream.getTracks().forEach(t => t.stop());
      return;
    }

    if (stream.getAudioTracks().length === 0) {
      log('No audio track detected. Select a browser tab and enable Share tab audio.');
      stream.getTracks().forEach(t => t.stop());
      return;
    }

  audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 48000 });
  await audioCtx.audioWorklet.addModule('./pcm-16k-worklet.js');

  sourceNode = audioCtx.createMediaStreamSource(stream);

  // Create the worklet
  node = new AudioWorkletNode(audioCtx, 'pcm16k-writer', {
    numberOfInputs: 1,
    numberOfOutputs: 1, // keep the graph running
    channelCount: 1,
    processorOptions: { targetSampleRate: 16000, chunkMs: 100 }
  });

  // Tirer le graphe sans faire de son (gain=0)
  pullGain = audioCtx.createGain();
  pullGain.gain.value = 0;

  sourceNode.connect(node);
  node.connect(pullGain);
  pullGain.connect(audioCtx.destination);

  // WS binaire vers ton serveur STT
  const wsUrl = getWsUrl();
  audioWs = new WebSocket(wsUrl);
  audioWs.binaryType = 'arraybuffer';
  audioWs.onopen = () => {
    const key = getStoredLicenseKey();
    if (key) {
      audioWs.send(JSON.stringify({ cmd: 'license', key }));
    }
    // Tell server this is an ingest client (no broadcasts)
    audioWs.send(JSON.stringify({ cmd: 'hello', client: 'ingest' }));
    log('Audio WebSocket connected');
  };
  audioWs.onerror = (e) => log('WS audio error: ' + e.message);
  audioWs.onclose = () => log('Audio WebSocket closed');

  // PCM16 chunks from worklet -> send over WS
  node.port.onmessage = (ev) => {
    const { type, payload } = ev.data || {};
    if (type === 'chunk' && payload && audioWs && audioWs.readyState === WebSocket.OPEN) {
      audioWs.send(payload); // payload est un ArrayBuffer de PCM16LE 16k mono
    }
  };

  // Resume audio context if needed
  if (audioCtx.state === 'suspended') await audioCtx.resume();

    startBtn.disabled = true;
    stopBtn.disabled = false;

    // If user stops sharing from browser UI
    (stream.getVideoTracks()[0] || stream.getAudioTracks()[0])?.addEventListener('ended', stopShare);

    log('Capture started. If you chose Chrome Tab, make sure Share tab audio is enabled.');
  } catch (err) {
    log(`Start error: ${err.name}: ${err.message}`);
    if (err.name === 'NotAllowedError') log('Browser blocked access. Click again and allow sharing.');
    if (err.name === 'NotSupportedError') log('Not supported here. Try updated Chrome/Edge, Brave with Shields off, or Full screen + system audio.');
  }
}

function stopShare() {
  try { sourceNode && sourceNode.disconnect(); } catch {}
  try { audioCtx && audioCtx.close(); } catch {}
  if (stream) { stream.getTracks().forEach(t => t.stop()); }
  stream = null; sourceNode = null; audioCtx = null;
  document.getElementById('start').disabled = false;
  document.getElementById('stop').disabled = true;
  log('Capture stopped.');
}

document.getElementById('start').addEventListener('click', startShare);
document.getElementById('stop').addEventListener('click', stopShare);
    </script>
	
</body>
</html>


